从这一课开始的内容以了解为主

递归 Recursion

什么是递归：

        就是函数自己调用了自己。
        比如：
        
        public int recSum(int n){
              if(n = 0){
                 return 0;
              }
              else{
                 int sum = n + recSum(n-1);   <-注意它调用了自己
                 return sum;
              }       
        }
    
        调用自己会发生什么？
        其实不会发生什么特殊的事情，因为它不知道它调用的那个函数是自己，
        它只会傻傻的执行，跟在别的函数里调用它没有区别。
        它会停止当前的工作，优先算完后调用的那个里面的内容。
        比如上例中，recSum(n)会暂时停止返还，而优先计算recSum(n-1)。
        但是你要知道recSum(n-1)里面又会有递归，所以它又会去算recSum(n-1);
        就这样一直下去，直到n==0,因为我们看到n==0的时候是没有递归的。
        然后recSum(0)会直接返还0,然后recSum(1)返还1 + 0，然后recSum(2)返还2+1+0，直到recSum(n)。
        知道这个方法在干什么了吗？它在算n+(n-1)+(n-2)+...+1+0的等差数列。
        所以递归其实相当于一个循环，只不过能实现的事情更多一些。
        
        一个递归方法一般有以下几个部分：
      
        1. base case      :     即在什么情况下不递归。你可以理解为什么时候该弹出来了。
                                                                    如果没有这个则递归会一直进行，最后导致栈溢出。
        
        2. 调用自己       :     一般需要新的参数，比如上例中n变成n-1;
        
        3. 怎么用调用自己返还的值, 比如上例中n+recSum(n-1);
        
    实例：见recursion.java
    
    
    
     栈溢出错误 (stackOverflow)：
     
             当一个递归函数无法终止（或者递归次数特别特别多）的时候，一个栈溢出stack overflow
             错误就出现了。
             
             为什么是栈？
                     你应该已经了解过栈是什么了。以防你忘了，栈是一种储存数据的方式，你可以把它比作一个有底的桶，
                     我们先放一个东西进去，再放一个东西进去，现在如果我们要把先放进去的东西拿出来，就必须先把后放进去的东西拿出来。
                     也就是所谓的先进后出，后进先出。
                     计算机调用函数的过程，其实就是栈的一种运用。
                     我们知道，一个函数func1如果调用了另一个函数func2，那么func2将先得到执行，func2结束以后继续执行func1。
                  
                     我们如何从栈的角度来理解这个行为呢：           
                     我们把所有的函数都存在一个栈里，程序只能运行栈顶（出口）处的数据（因为如果想访问栈里面的数据，就必须把顶部的东西都拿出来）
                     
                     画图理解：（注：下面是顶，上面是底）
                     
                     刚开始，什么都没有：
                     ――――――――――――――
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |             <--顶部
                    
                    开始执行main()：
                     ――――――――――――――
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |     main     |             <--把main()入栈
                    
         main调用了一个方法func1()，
                  这个时候把main推下去，func1入栈：
                     ――――――――――――――
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |     main     |
                    |     func1    |             <--现在执行func1
                    
                    然后func1()调用了func2()，同理，继续推：
                    
                     ――――――――――――――
                    |              |
                    |              |
                    |              |
                    |              |
                    |     main     |
                    |     func1    | 
                    |     func2    |             <--现在执行func2
                    
         func2执行完毕，func2出栈，
                   然后func1在栈顶，所以继续执行func1剩余的指令：
                     
                     ――――――――――――――
                    |              |
                    |              |
                    |              |             
                    |              |
                    |              |
                    |     main     |
                    |     func1    |             <--func2已经出来了
                    
         func1完毕，出栈：
         
                     ――――――――――――――
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |              |
                    |     main     |             <--func1出来，继续main
                    
         main结束，完毕。
         
         
         这大概就是调用函数的时候计算机在做的事情。
         回到我们关于递归的话题。递归函数在调用自己的时候，其实跟调用别人一样的事情。
         假如一个递归函数rec()递归了四次到底（base case条件判断为真），那在开始出栈时栈里面大概是这样：
         
                     ――――――――――――――
                    |              |
                    |              |
                    |     main     |
                    |     func     |
                    |     func     |
                    |     func     | 
                    |     func     |
                    
         然后依次出栈。
         
         但当然，计算机的内存不是无穷的，所以栈的大小也是有限的。
         所以当你的递归函数调用自己太多次了以后（比如无限递归），栈空间不够了，它就溢出了（溢出就是不够的意思）。
         这就是为什么会有栈溢出错误。
         这也是为什么你们要考栈。
        
        
        